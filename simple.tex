\documentclass[12pt]{article}

\usepackage[spanish]{babel}
\usepackage{amsfonts}
\usepackage[utf8]{inputenx}
\usepackage{algorithm2e}
\usepackage{listings}

\usepackage{color}
\definecolor{deepblue}{RGB}{0,0,153}
\definecolor{deepred}{RGB}{153,0,0}
\definecolor{deepgreen}{RGB}{51,102,0}
\definecolor{deepyellow}{RGB}{204,204,0}

\lstset{ %
			language=Python,
			basicstyle=\footnotesize,
			numbers=left,
			stepnumber=1,
			numbersep=4pt,
			tabsize=2,
			otherkeywords={self}, 
			keywordstyle=\color{deepred},
			stringstyle=\color{deepgreen},
			commentstyle=\color{deepblue},
}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black,
    linktoc=all
}


\title{Distancia de Edición}
\author{
        Alejandro Pernin \\
                \and
        Lautaro Medrano\\
}
\date{\today}



\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage

\section{Enunciado}
\textbf{\underline{Distancia de edición}}
Para convertir una cadena de caracteres x [1..m ] en otra cadena y [1..n ] , se pueden
realizar distintas operaciones. La meta consiste, en dadas las cadenas x e y ,
encontrar una serie de transformaciones para cambiar x en y , para lo cual debemos
emplear un vector z (cuyo tamaño asumimos que es suficiente para almacenar todos los
caracteres necesarios) en el que almacenaremos los resultados parciales. Al inicio z
está vacío y al final se cumple que z [ j ]= y [ j] para j=1,2 , ... , n . Se deben examinar
todos los caracteres de x , para lo cual se mantienen los índices i en x y j en z .
En un principio i= j=1 y al final i=m+ 1 . En cada paso se aplica alguna de las
siguientes seis operaciones (transformaciones):
\\\\
\textbf{Copiar:}copia un carácter de x a z . Esto es: z [ j ]= x [i ] e incrementa los índices i
yj
\\\\
\textbf{Reemplazar:}reemplaza un carácter de x por otro carácter c . Esto es: z [ j ]=c e
incrementa los índices i y j
\\\\
\textbf{Borrar:}borra un carácter de x incrementando i y sin mover j
\\\\
\textbf{Insertar:} inserta un carácter c en z . Esto es: z [ j ]=c e incrementa j sin mover i
\\\\
\textbf{Intercambiar:} intercambia los próximos dos caracteres copiándolos de x a z pero en
orden inverso. Esto es: z [ j ]= x [i+ 1] y z [ j +1]= x [i ] e incrementa los índices de la
siguiente manera: i=i+2 y j= j+2
\\\\
\textbf{Terminar:} elimina los caracteres restantes de x haciendo i=m+ 1 . Esta operación
descarta todos los caracteres de x que todavía no se analizaron. Es la última operación
se aplica si hace falta.

\newpage
\subsection{Distancia de edición}
Dadas dos cadenas x [1..m] e y [1..n ] y el costo de cada una de las operaciones
. Escribir un programa (programación dinámica) que calcule la distancia de edición
siendo esta la secuencia de menor costo que permita transformar x en y .
Analizar la complejidad en tiempo y espacio de la solución implementada.
El programa debe tomar como parámetros las dos cadenas y el nombre de un
archivo con el costo de las operaciones. El formato de cada línea de este archivo
es el siguiente:

\verb# <operacion>:<costo>#

Ejemplo de invocación: \emph{tdatp2 algoritmo altruista costos.txt}

La salida debe ser por pantalla y debe mostrar una línea por cada operación,
indicando los caracteres que se insertan o reemplazan. Una línea en blanco y el costo total de
la secuencia.

\subsection{Alineación secuencias ADN}
El problema de la distancia de edición, tal como está planteado en este TP generaliza el
problema de alinear dos secuencias de ADN. Existen varios métodos para medir la
similitud entre dos secuencias de ADN alineándolas. Uno de esos métodos consiste en
insertar espacios en posiciones arbitrarias en ambas secuencias (incluyendo al final) tal
que las secuencias resultantes tengan la misma longitud pero que no tengan espacios en
la misma posición. Entonces se le asigna un puntaje a cada posición de la siguiente
manera:

\begin{itemize}
	\item +1 si $x'[j]=y'[j]$ y ninguno es un espacio
	\item -1 si $x'[j]\neq y'[j]$ y ninguno es un espacio
	\item -1 si $x'[j]$ o $y'[j]$ es un espacio
\end{itemize}

El puntaje total de la alineación es la suma de los puntaje de cada posición. Por ejemplo
dadas las secuencias x=GATCGGCAT e y=CAATGTGAATC, una alineación posible
es:
\[
\begin{array}{ccccccccccccc}
  &G &\space &A &T &C &G &\space &G &C &A &T &\space  \\
  &C &A &A &T &\space &G &T &G &A &A &T &C	\\
  &-1 &-2 &+1 &+1 &-2 &+1 &-2 &+1 &-1 &+1 &+1 &-2
\end{array}
\]
Tal que el puntaje total de la alineación es $6*1-2*1-4*2=-4$
Explicar que como utilizar el programa de distancia de edición del punto 1
utilizando un subconjunto de las operaciones copiar, reemplazar, borrar, insertar,
intercambiar y terminar para resolver el problema de la alineación de secuencias de
ADN con el método dado.

\newpage
\section{Resolución}
\subsection{Distancia de edición}
Para la resolución de los problemas planteados se tuvieron en cuenta
algunas hipótesis:

\begin{itemize}
	\item El costo individual de copiar y reemplazar, son menores que los costos de las
combinaciones de borrar e insertar.
	\item Conozco soluciones parciales anteriores del problema.
	\item El problema es case sensitive, por lo cual mayúsculas y minúsculas serán
diferenciadas.
	\item Las operaciones estan sujetas a prohibición.
\end{itemize}

El problema se atacó desde un punto de vista dinámico utilizando el enfoque de
memorización, es decir que se van guardando en memoria soluciones previas a un problema
menor, cuya solución considero es óptima.
Para ello se utilizó un diccionario que irá alojando las soluciones previas para tenerlas
disponibles para ensamblar soluciones futuras. El concepto de solución es:
\begin{itemize}
	\item $S_{n}=S_{n-1}+s(n)$
\end{itemize}

Es decir que la solución hasta un carácter se compone de la solución hasta el carácter anterior
más una solución para ese único carácter.

Para la composición de la solución se hace uso de la hipótesis de que la
copia es la mejor operacion a realizar (menor costo), para poder realizar
una toma de decisiones se utiliza como recursos el resultado obtenido de
una implementación de LCS\footnote{Longest Common Sequence - Secuencia Común más Larga}
y un análisis de la diferencia de tamaños entre la base y el objetivo.

Algunas de las consideraciones que se toman en cuenta son:
\begin{itemize}
	\item Si $base(pos)\in LCS \rightarrow$ es un caracter que se puede 
	copiar, si se puede copiar esa misma instancia u otra con sus respectivos
	impactos.
	\item Si $|base| <= |objetivo| \rightarrow$ borrar un caracter implica 
	a futuro una inserción.
	\item Si $|base| >= |objetivo| \rightarrow$ una inserción puede a futuro
	implicar un borrar o terminar.
\end{itemize}

Teniendo en cuenta estas consideraciones se hace un análisis de costos y 
de que operación es la óptima a efectuar.
\\

\begin{algorithm}[H]
	\SetAlgoLined
	
	\KwData{n}
	\KwResult{lista\_solucion }
	
	\If {$post == 0$}{
			return $s(n)$;
	}
	\If {$!Dict_{n-1}$}{
			$Dict_{n-1}=S_{n-1}$\;
	}
	\If {$!Dict_{n}$}{
			$Dict_{n-1}=Dict_{n-1}+s(n)$\;
	}
	$l\leftarrow Dict_{n}$\;
	return $l$;

\caption{Obtención $S_{n}$ con memorización}
\end{algorithm}

\subsection{Alineación secuencias ADN}
Para la resolución del problema de alinear secuencias de ADN se utiliza 
el mismo algoritmo utilizado para la distancia de edición, utilizando un
conjunto de operaciones adaptados a este problema. Para hallar que operaciones
y que respectivos costos se debieran utilizar se hizo un analisis del problema.
Veamos el ejemplo de alineación:

\[
\begin{array}{clcccc}
 & &1 &2 &3 &4 \\
  &base: &G &\space &A &C \\
  &objetivo: &C &A &A&\space \\
  &costo: &-1 &-2 &+1 &-2 
\end{array}
\]

\begin{itemize}
	\item 1) Representa un reemplazo con un costo de -1.
	\item 2) Representa una inserción con un costo de -2.
	\item 3) Representa un copiar con un costo de +1.
	\item 4) Representa un borrar con un costo de -2.
	\item No se realizan operaciones terminar o intercambiar.
\end{itemize}

El objetivo de la alineación es obtener aquella alineación cuyo puntaje
es máximo, pero siendo que el algoritmo a utilizar trabaja con mínimos,
lo que se debe realizar es invertir los costos (eg: Copiar:-1); asi mismo
el resultado que obtendremos también debemos invertirlo para que represente
el puntaje máximo.
Por ejemplo el archivo de costos a utilizar sería:
\begin{lstlisting}
reemplazar:1
insertar:2
borrar:2
copiar:-1
\end{lstlisting}

Utilizando este archivo para la resolución de las secuencias dadas como
ejemplo obtenemos:
\begin{lstlisting}
reemplazar g c
copiar a
insertar a
copiar t
reemplazar c g
reemplazar g t
copiar g
reemplazar c a
copiar a
copiar t
insertar c

El costo es: 3
\end{lstlisting}
Cuyo puntaje de alineacion es -3 y equivale a:
\[
\begin{array}{ccccccccccccc}
  &G &\space &A &T &C &G &G &C &A &T &\space  \\
  &C &A &A &T &G &T &G &A &A &T &C	\\
  &-1 &-2 &+1 &+1 &-1 &-1 &+1 &-1 &+1 &+1 &-2
\end{array}
\]

\newpage
\lstinputlisting{testing2.py}
\end{document}
